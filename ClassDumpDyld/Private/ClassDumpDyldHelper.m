//
//  ClassDumpDyldHelper.m
//  ClassDumpDyld
//
//  Created by JH on 2024/1/26.
//

#import "ClassDumpDyldHelper.h"
#import <mach-o/dyld.h>
@implementation ClassDumpDyldHelper

+ (BOOL)isMachOExecutable:(const char *)image {
    FILE *machoFile = fopen(image, "rb");

    if (machoFile == 0) {
        return NO;
    }

    //#ifdef __LP64__
    struct mach_header_64 machHeader;
    //#else
    // mach_header machHeader;
    //#endif

    unsigned long n = fread(&machHeader, sizeof(machHeader), 1, machoFile);

    if (n != 1) {
        fclose(machoFile);
        return NO;
    }

    BOOL isExec = machHeader.filetype == MH_EXECUTE;

    fclose(machoFile);
    return isExec;
}

+ (BOOL)is64BitMachO:(const char *)image {
    FILE *machoFile = fopen(image, "rb");

    if (machoFile == 0) {
        fclose(machoFile);
        return NO;
    }

    struct mach_header_64 machHeader;
    unsigned long n = fread(&machHeader, sizeof(machHeader), 1, machoFile);

    if (n != 1) {
        fclose(machoFile);
        return NO;
    }

    BOOL is64 = machHeader.magic != MH_MAGIC;  // instead of ==MH_MAGIC_64
    fclose(machoFile);
    return is64;
}

+ (BOOL)fileExistsOnDisk:(const char *)image {
    FILE *aFile = fopen(image, "r");
    BOOL exists = aFile != 0;

    fclose(aFile);
    return exists;
}

+ (BOOL)isArch64 {
#ifdef __LP64__
    return YES;

#endif
    return NO;
}

+ (long)locationOfString:(const char *)haystack needle:(const char *)needle {
    const char *found = strstr(haystack, needle);
    long anIndex = -1;

    if (found != NULL) {
        anIndex = found - haystack;
    }

    return anIndex;
}

+ (BOOL)hasMalformedIDWithParts:(NSString *)parts {
    if ([parts rangeOfString:@"@\""].location != NSNotFound &&
        [parts rangeOfString:@"@\""].location + 2 < parts.length - 1 &&
        ([[parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2] rangeOfString:@"\""]
         .location == [[parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2]
                       rangeOfString:@"\"\""]
         .location ||
         [[parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2] rangeOfString:@"\""]
         .location == [[parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2]
                       rangeOfString:@"\"]"]
         .location ||
         [[parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2] rangeOfString:@"\""]
         .location ==
         [parts substringFromIndex:[parts rangeOfString:@"@\""].location + 2].length - 1)) {
        return YES;
    }

    return NO;
}

@end


long locationOfString(const char *haystack, const char *needle) {
    const char *found = strstr(haystack, needle);
    long anIndex = -1;

    if (found != NULL) {
        anIndex = found - haystack;
    }

    return anIndex;
}

BOOL isMachOExecutable(const char *image) {
    FILE *machoFile = fopen(image, "rb");

    if (machoFile == 0) {
        return NO;
    }

    //#ifdef __LP64__
    struct mach_header_64 machHeader;
    //#else
    // mach_header machHeader;
    //#endif

    unsigned long n = fread(&machHeader, sizeof(machHeader), 1, machoFile);

    if (n != 1) {
        fclose(machoFile);
        return NO;
    }

    BOOL isExec = machHeader.filetype == MH_EXECUTE;

    fclose(machoFile);
    return isExec;
}

BOOL is64BitMachO(const char *image) {
    FILE *machoFile = fopen(image, "rb");

    if (machoFile == 0) {
        fclose(machoFile);
        return NO;
    }

    struct mach_header_64 machHeader;
    unsigned long n = fread(&machHeader, sizeof(machHeader), 1, machoFile);

    if (n != 1) {
        fclose(machoFile);
        return NO;
    }

    BOOL is64 = machHeader.magic != MH_MAGIC;  // instead of ==MH_MAGIC_64
    fclose(machoFile);
    return is64;
}

BOOL fileExistsOnDisk(const char *image) {
    FILE *aFile = fopen(image, "r");
    BOOL exists = aFile != 0;

    fclose(aFile);
    return exists;
}

BOOL arch64(void) {
    // size_t size;
    // sysctlbyname("hw.cpu64bit_capable", NULL, &size, NULL, 0);
    // BOOL cpu64bit;
    // sysctlbyname("hw.cpu64bit_capable", &cpu64bit, &size, NULL, 0);
    // return cpu64bit;

#ifdef __LP64__
    return YES;

#endif
    return NO;
}

NSString * copyrightMessage(char *image) {
    @autoreleasepool {
        NSString *version = [NSProcessInfo processInfo].operatingSystemVersionString;
        NSLocale *loc = [NSLocale localeWithLocaleIdentifier:@"en-us"];
        NSString *date = [NSDate.date descriptionWithLocale:loc];

        NSString *message = [[NSString alloc] initWithFormat:@"/*\n\
    * This header is generated by "
                             @"classdump-dyld 1.0\n\
    * on %@\n\
    * "
                             @"Operating System: %@\n\
    * Image Source: "
                             @"%s\n\
    * classdump-dyld is licensed under "
                             @"GPLv3, Copyright \u00A9 2013-2016 by "
                             @"Elias Limneos.\n\
    */\n\n", date, version, image];

        return message;
    }
}

void loadBar(int x, int n, int r, int w, const char *className) {
    //    return;
    // Only update r times.
    if ((n / r) < 1) {
        return;
    }

    if (x % (n / r) != 0) {
        return;
    }

    // Calculuate the ratio of complete-to-incomplete.
    float ratio = x / (float)n;
    int c = ratio * w;

    // Show the percentage complete.
    printf("%3d%% [", (int)(ratio * 100));

    // Show the load bar.
    for (int x = 0; x < c; x++) {
        printf("=");
    }

    for (int x = c; x < w; x++) {
        printf(" ");
    }

    // ANSI Control codes to go back to the
    // previous line and clear it.
    printf("] %s %d/%d <%s>\n\033[F\033[J", [print_free_memory() UTF8String], x, n, className);
}

NSString * print_free_memory(void) {
    mach_port_t host_port;
    mach_msg_type_number_t host_size;
    vm_size_t pagesize;

    host_port = mach_host_self();
    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);
    host_page_size(host_port, &pagesize);

    vm_statistics_data_t vm_stat;

    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&vm_stat, &host_size) != KERN_SUCCESS) {
        // Failed to fetch vm stats
    }

    natural_t mem_free = vm_stat.free_count * (natural_t)pagesize;

    if (mem_free < 10000000) {  // break if less than 10MB of RAM
        printf("Error: Out of memory. You can repeat with -s option to continue from where left.\n\n");
        exit(0);
    }

    if (mem_free < 20000000) {  // warn if less than 20MB of RAM
        return [NSString stringWithFormat:@"Low Memory: %u MB free. Might exit to prevent system hang",
                (mem_free / 1024 / 1024)];
    } else {
        return [NSString stringWithCString:"" encoding:NSASCIIStringEncoding];
        // return [NSString stringWithFormat:@"Memory: %u MB free",(mem_free/1024/1024)] ;
    }
}
